{
  "language": "Solidity",
  "sources": {
    "contracts/swappers/Liquidations/USTSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface CurvePool {\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy, address receiver) external returns (uint256);\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n    function add_liquidity(uint256[3] memory amounts, uint256 _min_mint_amount) external;\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n    function deposit(IERC20 token, address from, address to, uint256 amount, uint256 share) external returns(uint256, uint256);\n}\n\ncontract USTSwapper is ISwapperGeneric {\n\n     // Local variables\n    IBentoBoxV1 public constant bentoBox = IBentoBoxV1(0xF5BCE5077908a1b7370B9ae04AdC565EBd643966);\n    CurvePool public constant MIM3POOL = CurvePool(0x5a6A4D54456819380173272A5E8E9B9904BdF41B);\n    CurvePool constant public UST3POOL = CurvePool(0x890f4e345B1dAED0367A877a1612f86A1f86985f);\n    IERC20 public constant MIM = IERC20(0x99D8a9C45b2ecA8864373A26D1459e3Dff1e17F3);\n    IERC20 public constant UST = IERC20(0xa47c8bf37f92aBed4A126BDA807A7b7498661acD);\n    IERC20 public constant ThreePOOL = IERC20(0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490);\n\n    constructor() public {\n        ThreePOOL.approve(address(MIM3POOL), type(uint256).max);\n        UST.approve(address(UST3POOL), type(uint256).max);\n        MIM.approve(address(bentoBox), type(uint256).max);\n    }\n\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n\n        (uint256 amountFrom, ) = bentoBox.withdraw(UST, address(this), address(this), 0, shareFrom);\n\n        uint256 amountIntermediate = UST3POOL.exchange(0, 1, amountFrom, 0);\n\n        uint256 amountTo = MIM3POOL.exchange(1, 0, amountIntermediate, 0);\n\n        (, shareReturned) = bentoBox.deposit(MIM, address(this), recipient, amountTo, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0,0);\n    }\n}"
    },
    "contracts/interfaces/ISwapperGeneric.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.6.12;\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\ninterface ISwapperGeneric {\n    /// @notice Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for at least 'amountToMin' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Returns the amount of tokens 'to' transferred to BentoBox.\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swap(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) external returns (uint256 extraShare, uint256 shareReturned);\n\n    /// @notice Calculates the amount of token 'from' needed to complete the swap (amountFrom),\n    /// this should be less than or equal to amountFromMax.\n    /// Withdraws 'amountFrom' of token 'from' from the BentoBox account for this swapper.\n    /// Swaps it for exactly 'exactAmountTo' of token 'to'.\n    /// Transfers the swapped tokens of 'to' into the BentoBox using a plain ERC20 transfer.\n    /// Transfers allocated, but unused 'from' tokens within the BentoBox to 'refundTo' (amountFromMax - amountFrom).\n    /// Returns the amount of 'from' tokens withdrawn from BentoBox (amountFrom).\n    /// (The BentoBox skim function will be used by the caller to get the swapped funds).\n    function swapExact(\n        IERC20 fromToken,\n        IERC20 toToken,\n        address recipient,\n        address refundTo,\n        uint256 shareFromSupplied,\n        uint256 shareToExact\n    ) external returns (uint256 shareUsed, uint256 shareReturned);\n}\n"
    },
    "contracts/swappers/Liquidations/UsdcAvaxSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"../../interfaces/ISwapperGeneric.sol\";\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract UsdcAvaxSwapper is ISwapperGeneric {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant USDCAVAX = IUniswapV2Pair(0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 public constant USDC = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n\n    constructor() {\n        MIM.approve(address(DEGENBOX), type(uint256).max);\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    /// @inheritdoc ISwapperGeneric\n    function swap(\n        IERC20,\n        IERC20,\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public override returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(IERC20(address(USDCAVAX)), address(this), address(this), 0, shareFrom);\n\n        USDCAVAX.transfer(address(USDCAVAX), amountFrom);\n        (uint256 usdcAmount, uint256 avaxAmount) = USDCAVAX.burn(address(this));\n        \n        // swap USDC to AVAX\n        (uint256 reserve0, uint256 reserve1, ) = USDCAVAX.getReserves();\n        uint256 avaxFromUsdc = _getAmountOut(usdcAmount, reserve0, reserve1);\n        USDC.transfer(address(USDCAVAX), usdcAmount);\n        USDCAVAX.swap(0, avaxFromUsdc, address(this), new bytes(0));\n        avaxAmount += avaxFromUsdc;\n\n        // swap AVAX to MIM\n        (reserve0, reserve1, ) = MIMAVAX.getReserves();\n        uint256 mimFromAvax = _getAmountOut(avaxAmount, reserve1, reserve0);\n        WAVAX.transfer(address(MIMAVAX), avaxAmount);\n        MIMAVAX.swap(mimFromAvax, 0, address(this), new bytes(0));\n\n        (, shareReturned) = DEGENBOX.deposit(MIM, address(this), recipient, mimFromAvax, 0);\n        extraShare = shareReturned - shareToMin;\n    }\n\n    // Swaps to an exact amount, from a flexible input amount\n    /// @inheritdoc ISwapperGeneric\n    function swapExact(\n        IERC20,\n        IERC20,\n        address,\n        address,\n        uint256,\n        uint256\n    ) public override returns (uint256 shareUsed, uint256 shareReturned) {\n        return (0, 0);\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/swappers/Leverage/UsdcAvaxLevSwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.4;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol\";\nimport \"../../libraries/Babylonian.sol\";\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n}\n\ninterface IBentoBoxV1 {\n    function withdraw(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n\n    function deposit(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256, uint256);\n}\n\ncontract UsdcAvaxLevSwapper {\n    IBentoBoxV1 public constant DEGENBOX = IBentoBoxV1(0x1fC83f75499b7620d53757f0b01E2ae626aAE530);\n    IUniswapV2Pair public constant USDCAVAX = IUniswapV2Pair(0xA389f9430876455C36478DeEa9769B7Ca4E3DDB1);\n    IUniswapV2Pair public constant MIMAVAX = IUniswapV2Pair(0x781655d802670bbA3c89aeBaaEa59D3182fD755D);\n    IUniswapV2Router01 public constant ROUTER = IUniswapV2Router01(0x60aE616a2155Ee3d9A68541Ba4544862310933d4);\n\n    uint256 private constant DEADLINE = 0xf000000000000000000000000000000000000000000000000000000000000000; // ~ placeholder for swap deadline\n\n    IERC20 public constant MIM = IERC20(0x130966628846BFd36ff31a822705796e8cb8C18D);\n    IERC20 public constant WAVAX = IERC20(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    IERC20 public constant USDC = IERC20(0xA7D7079b0FEaD91F3e65f86E8915Cb59c1a4C664);\n\n    constructor() {\n        USDCAVAX.approve(address(DEGENBOX), type(uint256).max);\n        WAVAX.approve(address(ROUTER), type(uint256).max);\n        USDC.approve(address(ROUTER), type(uint256).max);\n    }\n\n    function _calculateSwapInAmount(uint256 reserveIn, uint256 userIn) internal pure returns (uint256) {\n        return (Babylonian.sqrt(reserveIn * ((userIn * 3988000) + (reserveIn * 3988009))) - (reserveIn * 1997)) / 1994;\n    }\n\n    function _getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\n        amountOut = numerator / denominator;\n    }\n\n    // Swaps to a flexible amount, from an exact input amount\n    function swap(\n        address recipient,\n        uint256 shareToMin,\n        uint256 shareFrom\n    ) public returns (uint256 extraShare, uint256 shareReturned) {\n        (uint256 amountFrom, ) = DEGENBOX.withdraw(MIM, address(this), address(this), 0, shareFrom);\n\n        // Swap MIM to AVAX\n        (uint256 reserve0, uint256 reserve1, ) = MIMAVAX.getReserves();\n        uint256 avaxFromMim = _getAmountOut(amountFrom, reserve0, reserve1);\n        MIM.transfer(address(MIMAVAX), amountFrom);\n        MIMAVAX.swap(0, avaxFromMim, address(this), new bytes(0));\n\n        // Determine optimal amount of AVAX to swap for liquidity providing\n        (reserve0, reserve1, ) = USDCAVAX.getReserves();\n        uint256 avaxSwapInAmount = _calculateSwapInAmount(reserve1, avaxFromMim);\n        uint256 usdcAmount = _getAmountOut(avaxSwapInAmount, reserve1, reserve0);\n        WAVAX.transfer(address(USDCAVAX), avaxSwapInAmount);\n        USDCAVAX.swap(usdcAmount, 0, address(this), \"\");\n\n        ROUTER.addLiquidity(\n            address(USDC),\n            address(WAVAX),\n            USDC.balanceOf(address(this)),\n            WAVAX.balanceOf(address(this)),\n            1,\n            1,\n            address(this),\n            DEADLINE\n        );\n\n        (, shareReturned) = DEGENBOX.deposit(IERC20(address(USDCAVAX)), address(this), recipient, USDCAVAX.balanceOf(address(this)), 0);\n        extraShare = shareReturned - shareToMin;\n    }\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.4;\n\n/// @notice Babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method).\nlibrary Babylonian {\n    // computes square roots using the babylonian method\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}